{"paragraphs":[{"text":"%md\n\n### Implementing an Atomic N-N register \n\nIn this programming assignment you will have to complete the implementation of an atomic register that supports multiple writers and readers.\n\nWhen you are done you simply have to export your notebook and then upload it in the \"Programming Exercise 3\" page.\n\n**Things to Remember**:\n1. Basic components such as `PerfectLink`,  `Network` and `Timer` are already provided. No need to implement them.\n2. Execute the imports defined below **before** compiling your component implementations.\n3. We recommend making use of the component state and internal messages we have provided, if any, to complete the implementation logic.\n4. You can always print messages to the output log, from within handlers to see what happens during the simulation. e.g. `println(s\"Process $self delivers message $msg\");`\n5. Remember that during the simulation check you can print and observe the simulation time, i.e. with `System.currentTimeMillis()`.\n5. Do not forget to run the checker code block after each component implementation to ensure that all properties are satisfied **before** exporting and submitting the notebook.\n6. You can always restart the Kompics Interpreter to start fresh (Interpreter→KompicsInterpreter→Click Restart)\n\nGood luck! :)","dateUpdated":"2018-01-05T14:09:00+0000","config":{"editorSetting":{},"editorMode":"ace/mode/scala","colWidth":12,"editorHide":true,"fontSize":9,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Implementing an Atomic N-N register</h3>\n<p>In this programming assignment you will have to complete the implementation of an atomic register that supports multiple writers and readers.</p>\n<p>When you are done you simply have to export your notebook and then upload it in the &ldquo;Programming Exercise 3&rdquo; page.</p>\n<p><strong>Things to Remember</strong>:<br/>1. Basic components such as <code>PerfectLink</code>, <code>Network</code> and <code>Timer</code> are already provided. No need to implement them.<br/>2. Execute the imports defined below <strong>before</strong> compiling your component implementations.<br/>3. We recommend making use of the component state and internal messages we have provided, if any, to complete the implementation logic.<br/>4. You can always print messages to the output log, from within handlers to see what happens during the simulation. e.g. <code>println(s&quot;Process $self delivers message $msg&quot;);</code><br/>5. Remember that during the simulation check you can print and observe the simulation time, i.e. with <code>System.currentTimeMillis()</code>.<br/>5. Do not forget to run the checker code block after each component implementation to ensure that all properties are satisfied <strong>before</strong> exporting and submitting the notebook.<br/>6. You can always restart the Kompics Interpreter to start fresh (Interpreter→KompicsInterpreter→Click Restart)</p>\n<p>Good luck! :)</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1515161340376_-494057230","id":"20160920-133253_275876456","dateCreated":"2018-01-05T14:09:00+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:297"},{"text":"//Rremember to execute the following imports first\nimport se.kth.edx.id2203.core.ExercisePrimitives._\nimport se.kth.edx.id2203.core.Ports._\nimport se.kth.edx.id2203.validation._\nimport se.sics.kompics.network._\nimport se.sics.kompics.sl.{Init, _}\nimport se.sics.kompics.{ComponentDefinition => _, Port => _,KompicsEvent}\n\nimport scala.collection.mutable.Map\nimport scala.language.implicitConversions","dateUpdated":"2018-01-05T15:34:00+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"editorHide":false,"fontSize":9,"results":{},"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1515161340378_-493287732","id":"20160830-120308_471915891","dateCreated":"2018-01-05T14:09:00+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:298","user":"anonymous","dateFinished":"2018-01-05T15:34:00+0000","dateStarted":"2018-01-05T15:34:00+0000","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"import se.kth.edx.id2203.core.ExercisePrimitives._<br />import se.kth.edx.id2203.core.Ports._<br />import se.kth.edx.id2203.validation._<br />import se.sics.kompics.network._<br />import se.sics.kompics.sl.{Init, _}<br />import se.sics.kompics.{ComponentDefinition=>_, Port=>_, KompicsEvent}<br />import scala.collection.mutable.Map<br />import scala.language.implicitConversions<br />"}]}},{"text":"%md\n\n### Mini Scala-Refresher : The Scala Option ###\n\nIn this assignment you will have to work with Option types, so let's recap how they work. An `Option[T]` is a container for a value of type `T` which is **optional**. \nThat means that in case the value has been set, then `Option[T]` is actually an instance of `Some[T]`, which in turn contains the actual value of type `T`. \nIn case its value has not been set then the `Option[A]` is the object `None`.\n\nThus, it is good to have in mind the following e.g. for any  `value: Option[Any]`:\n\n\n1.When you want to initialize your optional value do it as such: \n```scala \nvalue = Some(myInitialValue) \n//or\nvalue = None;\n```\n2.In case you need to provide a default value in case of a `None` when you want to access an optional type you can do so like this:\n```scala\nval myVal:T = value.getOrElse(myDefaultValue)\n```\nOtherwise you can always simply get its value when you are sure it is not `None` like this:\n```scala\nif(value.isDefined){\n    myVal = value.get\n}\n```\n3.Beware of the following assignment: for `val myVal :Option[Any] = Some(1334)` then `val myOtherVal : Option[Any] = Some(myVal)` will not be `Some(1334)` but `Some(Some(1334))`","dateUpdated":"2018-01-05T14:09:00+0000","config":{"editorSetting":{},"editorMode":"ace/mode/scala","colWidth":12,"editorHide":true,"fontSize":9,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h3>Mini Scala-Refresher : The Scala Option</h3>\n<p>In this assignment you will have to work with Option types, so let&rsquo;s recap how they work. An <code>Option[T]</code> is a container for a value of type <code>T</code> which is <strong>optional</strong>.<br/>That means that in case the value has been set, then <code>Option[T]</code> is actually an instance of <code>Some[T]</code>, which in turn contains the actual value of type <code>T</code>.<br/>In case its value has not been set then the <code>Option[A]</code> is the object <code>None</code>.</p>\n<p>Thus, it is good to have in mind the following e.g. for any <code>value: Option[Any]</code>:</p>\n<p>1.When you want to initialize your optional value do it as such: </p>\n<pre><code class=\"scala \">value = Some(myInitialValue) \n//or\nvalue = None;\n</code></pre>\n<p>2.In case you need to provide a default value in case of a <code>None</code> when you want to access an optional type you can do so like this:</p>\n<pre><code class=\"scala\">val myVal:T = value.getOrElse(myDefaultValue)\n</code></pre>\n<p>Otherwise you can always simply get its value when you are sure it is not <code>None</code> like this:</p>\n<pre><code class=\"scala\">if(value.isDefined){\n    myVal = value.get\n}\n</code></pre>\n<p>3.Beware of the following assignment: for <code>val myVal :Option[Any] = Some(1334)</code> then <code>val myOtherVal : Option[Any] = Some(myVal)</code> will not be <code>Some(1334)</code> but <code>Some(Some(1334))</code></p>\n</div>"}]},"apps":[],"jobName":"paragraph_1515161340378_-493287732","id":"20160920-163834_1484371572","dateCreated":"2018-01-05T14:09:00+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:299"},{"text":"%md\n\n## The N-N Atomic Register ##\n\nA (single) Atomic Register Abstraction (AR), in Kompics terms,  is a component that **provides** the following port *(already imported in the notebook)*.\n\n     class AtomicRegister extends Port {\n       request[AR_Read_Request]\n       request[AR_Write_Request]\n       indication[AR_Read_Response]\n       indication[AR_Write_Response]\n     }\n\n\nAn **AR** component should request reads (`AR_Read_Request`) or writes (`AR_Write_Request`) and respond with `AR_Read_Response` or `AR_Write_Response` events respectively as defined below:\n\n     case class AR_Read_Request() extends KompicsEvent\n     case class AR_Read_Response(value: Option[Any]) extends KompicsEvent\n     case class AR_Write_Request(value: Any) extends KompicsEvent\n     case class AR_Write_Response() extends KompicsEvent\n\n\nAs you have already learnt from the course lectures, Atomic Registers should be linerarizable and also terminate which we summarize with the following properties:\n\n1. **Termination**: *If a correct process invokes an operation, then the operation eventually completes.*\n2. **Atomicity**: *Every read operation returns the value that was written most recently in a hypothetical execution, where every failed operation appears to be complete or does not appear to have been invoked at all, and every complete operation appears to have been executed at some instant between its invocation and its completion.*\n\n\nHINT: The recommended algorithm to use in this assignment is *Read-Impose Write-Consult Majority* and is described at page 3 within the following  [document](https://d37djvu3ytnwxt.cloudfront.net/assets/courseware/v1/1c5fbe3090dfe445c8858e42c5925d0f/asset-v1:KTHx+ID2203.1x+2016T3+type@asset+block/atomicregister.pdf) in the respective lecture.\n","dateUpdated":"2018-01-05T15:51:51+0000","config":{"editorSetting":{"language":"markdown","editOnDblClick":true},"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"fontSize":9,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"tableHide":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>The N-N Atomic Register</h2>\n<p>A (single) Atomic Register Abstraction (AR), in Kompics terms, is a component that <strong>provides</strong> the following port <em>(already imported in the notebook)</em>.</p>\n<pre><code> class AtomicRegister extends Port {\n   request[AR_Read_Request]\n   request[AR_Write_Request]\n   indication[AR_Read_Response]\n   indication[AR_Write_Response]\n }\n</code></pre>\n<p>An <strong>AR</strong> component should request reads (<code>AR_Read_Request</code>) or writes (<code>AR_Write_Request</code>) and respond with <code>AR_Read_Response</code> or <code>AR_Write_Response</code> events respectively as defined below:</p>\n<pre><code> case class AR_Read_Request() extends KompicsEvent\n case class AR_Read_Response(value: Option[Any]) extends KompicsEvent\n case class AR_Write_Request(value: Any) extends KompicsEvent\n case class AR_Write_Response() extends KompicsEvent\n</code></pre>\n<p>As you have already learnt from the course lectures, Atomic Registers should be linerarizable and also terminate which we summarize with the following properties:</p>\n<ol>\n  <li><strong>Termination</strong>: <em>If a correct process invokes an operation, then the operation eventually completes.</em></li>\n  <li><strong>Atomicity</strong>: <em>Every read operation returns the value that was written most recently in a hypothetical execution, where every failed operation appears to be complete or does not appear to have been invoked at all, and every complete operation appears to have been executed at some instant between its invocation and its completion.</em></li>\n</ol>\n<p>HINT: The recommended algorithm to use in this assignment is <em>Read-Impose Write-Consult Majority</em> and is described at page 3 within the following <a href=\"https://d37djvu3ytnwxt.cloudfront.net/assets/courseware/v1/1c5fbe3090dfe445c8858e42c5925d0f/asset-v1:KTHx+ID2203.1x+2016T3+type@asset+block/atomicregister.pdf\">document</a> in the respective lecture.</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1515161340379_-493672481","id":"20160920-163704_1475979424","dateCreated":"2018-01-05T14:09:00+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:300","user":"anonymous","dateFinished":"2018-01-05T15:51:51+0000","dateStarted":"2018-01-05T15:51:51+0000"},{"text":"\n  //The following events are to be used internally by the Atomic Register implementation below\n  case class READ(rid: Int) extends KompicsEvent;\n  case class VALUE(rid: Int, ts: Int, wr: Int, value: Option[Any]) extends KompicsEvent;\n  case class WRITE(rid: Int, ts: Int, wr: Int, writeVal: Option[Any]) extends KompicsEvent;\n  case class ACK(rid: Int) extends KompicsEvent;\n\n  /**\n    * This augments tuples with comparison operators implicitly, which you can use in your code. \n    * examples: (1,2) > (1,4) yields 'false' and  (5,4) <= (7,4) yields 'true' \n    */\n  implicit def addComparators[A](x: A)(implicit o: math.Ordering[A]): o.Ops = o.mkOrderingOps(x);\n\n//HINT: After you execute the latter implicit ordering you can compare tuples as such within your component implementation:\n(1,2) <= (1,4);\n","dateUpdated":"2018-01-05T15:34:06+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"fontSize":9,"results":{},"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1515161340379_-493672481","id":"20160920-164336_1137661827","dateCreated":"2018-01-05T14:09:00+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:301","user":"anonymous","dateFinished":"2018-01-05T15:34:07+0000","dateStarted":"2018-01-05T15:34:06+0000","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"defined class READ<br />defined class VALUE<br />defined class WRITE<br />defined class ACK<br />addComparators: [A](x: A)(implicit o: scala.math.Ordering[A])o.Ops<br />res16: Boolean = true<br />"}]}},{"text":"\nclass ReadImposeWriteConsultMajority(init: Init[ReadImposeWriteConsultMajority]) extends ComponentDefinition {\n\n  //subscriptions\n\n  val nnar = provides[AtomicRegister];\n\n  val pLink = requires[PerfectLink];\n  val beb = requires[BestEffortBroadcast];\n\n  //state and initialization\n\n  val (self: Address, n: Int, selfRank: Int) = init match {\n    case Init(selfAddr: Address, n: Int) => (selfAddr, n, AddressUtils.toRank(selfAddr))\n  };\n\n  var (ts, wr) = (0, 0);\n  var value: Option[Any] = None;\n  var acks = 0;\n  var readval: Option[Any] = None;\n  var writeval: Option[Any] = None;\n  var rid = 0;\n  var readlist: Map[Address, (Int, Int, Option[Any])] = Map.empty\n  var reading = false;\n\n  //handlers\n\n  nnar uponEvent {\n    case AR_Read_Request() => handle {\n      rid = rid + 1;\n      acks = 0;\n      readlist = Map.empty;\n      reading = true;\n      trigger(BEB_Broadcast(READ(rid)) -> beb);\n    };\n    case AR_Write_Request(wval) => handle { \n      rid = rid + 1;\n      /*writeval = wval;*/\n      writeval = Some(wval);\n      acks = 0;\n      readlist = Map.empty;\n      trigger(BEB_Broadcast(READ(rid)) -> beb);\n    }\n  }\n\n  beb uponEvent {\n    case BEB_Deliver(src, READ(readID)) => handle {\n      trigger(PL_Send(src, VALUE(readID, ts, wr, value)) -> pLink);\n    }\n    case BEB_Deliver(src, w: WRITE) => handle {\n      if ((ts, wr)<(w.ts, w.wr)){\n        /*(ts, wr, value) = (w.ts, w.wr, w.writeVal)*/\n        ts = w.ts;\n        wr = w.wr;\n        value = Some(w.writeVal);\n      }\n      trigger(PL_Send(src, ACK(w.rid)) -> pLink);\n    }\n  }\n\n  pLink uponEvent {\n    case PL_Deliver(src, v: VALUE) => handle {\n      if (v.rid == rid) {\n        val myVal: Any = v.value.getOrElse(None);\n        readlist(src) <- (v.ts,  v.wr, myVal);\n        if(readlist.count() > n/2){\n          /*todo: check here*/\n          var (maxts, rr) = (0, 0);\n          readval = readval;\n          readlist = Map.empty;\n          if(reading){\n            val bcastval: Option[Any] = readval.getOrElse(None);\n          } else {\n            rr = selfRank;\n            val bcastval: Option[Any] = writeval.getOrElse(None);\n            trigger(BEB_Broadcast(WRITE(rid, maxts, rr, bcastval)) -> beb);\n          }\n        }\n      }\n    }\n    case PL_Deliver(src, v: ACK) => handle {\n      if (v.rid == rid) {\n        acks = acks + 1;\n        if(acks > n/2){\n          acks = 0;\n          if (reading){\n            reading = false;\n            trigger(AR_Read_Response(readval) -> nnar);\n          } else {\n            trigger(AR_Write_Response() -> nnar);\n          }\n        }\n      }\n    }\n  }\n}","dateUpdated":"2018-01-05T16:51:54+0000","config":{"lineNumbers":true,"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"fontSize":9,"results":{},"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1515161340379_-493672481","id":"20160830-120402_168996820","dateCreated":"2018-01-05T14:09:00+0000","status":"ERROR","progressUpdateIntervalMs":500,"$$hashKey":"object:302","user":"anonymous","dateFinished":"2018-01-05T16:51:54+0000","dateStarted":"2018-01-05T16:51:54+0000","results":{"code":"ERROR","msg":[{"type":"HTML","data":"<console>:65: error: ';' expected but '<-' found.<br />        readlist(src) <- (v.ts,  v.wr, myVal);<br />                      ^<br />"}]}},{"text":" checkNNAR[ReadImposeWriteConsultMajority]();","dateUpdated":"2018-01-05T14:09:00+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"fontSize":9,"results":{},"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1515161340379_-493672481","id":"20160830-120430_1188854740","dateCreated":"2018-01-05T14:09:00+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:303"},{"dateUpdated":"2018-01-05T14:09:00+0000","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala","colWidth":12,"fontSize":9,"results":{},"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1515161340379_-493672481","id":"20160830-120658_2133406867","dateCreated":"2018-01-05T14:09:00+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:304"}],"name":"Exercise-SharedMemory","id":"2D2GGQBQ9","angularObjects":{"2BKQCVH92:shared_process":[],"2CVXXPNWV:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}