{"paragraphs":[{"text":"%md\n\n## Distributed Consensus\n\nIn this final programming assignment for Part I of the course you will have to complete the implementation of a variation of the famous Paxos algorithm.\n\nWhen you are done you simply have to export your notebook and then upload it in the \"Programming Exercise 5\" page.\n\n**Things to Remember**:\n1. Basic components such as `PerfectLink` and  `Best-Effort Broadcast` are already provided. No need to implement them.\n2. Execute the imports defined below **before** compiling your component implementations.\n3. We recommend making use of the component state and internal messages we have provided, if any, to complete the implementation logic.\n4. You can always print messages to the output log, from within handlers to see what happens during the simulation. e.g. `println(s\"Process $self delivers message $msg\");`\n5. Remember that during the simulation check you can print and observe the simulation time, i.e. with `System.currentTimeMillis()`.\n5. Do not forget to run the checker code block after each component implementation to ensure that all properties are satisfied **before** exporting and submitting the notebook.\n6. You can always restart the Kompics Interpreter to start fresh (Interpreter→KompicsInterpreter→Click Restart)\n\nGood luck! :)","dateUpdated":"2018-01-09T16:35:23+0000","config":{"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"fontSize":9,"editorSetting":{"language":"markdown","editOnDblClick":true},"tableHide":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>Distributed Consensus</h2>\n<p>In this final programming assignment for Part I of the course you will have to complete the implementation of a variation of the famous Paxos algorithm.</p>\n<p>When you are done you simply have to export your notebook and then upload it in the &ldquo;Programming Exercise 5&rdquo; page.</p>\n<p><strong>Things to Remember</strong>:<br/>1. Basic components such as <code>PerfectLink</code> and <code>Best-Effort Broadcast</code> are already provided. No need to implement them.<br/>2. Execute the imports defined below <strong>before</strong> compiling your component implementations.<br/>3. We recommend making use of the component state and internal messages we have provided, if any, to complete the implementation logic.<br/>4. You can always print messages to the output log, from within handlers to see what happens during the simulation. e.g. <code>println(s&quot;Process $self delivers message $msg&quot;);</code><br/>5. Remember that during the simulation check you can print and observe the simulation time, i.e. with <code>System.currentTimeMillis()</code>.<br/>5. Do not forget to run the checker code block after each component implementation to ensure that all properties are satisfied <strong>before</strong> exporting and submitting the notebook.<br/>6. You can always restart the Kompics Interpreter to start fresh (Interpreter→KompicsInterpreter→Click Restart)</p>\n<p>Good luck! :)</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1515514951750_-1959993476","id":"20160927-134633_1462429338","dateCreated":"2018-01-09T16:22:31+0000","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:340","user":"anonymous","dateFinished":"2018-01-09T16:35:23+0000","dateStarted":"2018-01-09T16:35:23+0000"},{"text":"import se.kth.edx.id2203.core.ExercisePrimitives.AddressUtils._\nimport se.kth.edx.id2203.core.Ports._\nimport se.kth.edx.id2203.validation._\nimport se.sics.kompics.network._\nimport se.sics.kompics.sl.{Init, _}\nimport se.sics.kompics.{KompicsEvent, ComponentDefinition => _, Port => _}\nimport scala.language.implicitConversions\nimport scala.collection.mutable.ListBuffer;\n\nimport se.sics.kompics.timer.{ScheduleTimeout, Timeout, Timer}\n","dateUpdated":"2018-01-09T16:35:28+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"tableHide":false,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"fontSize":9,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1515514951751_-1959993476","id":"20160830-154917_187608468","dateCreated":"2018-01-09T16:22:31+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:341","user":"anonymous","dateFinished":"2018-01-09T16:35:28+0000","dateStarted":"2018-01-09T16:35:28+0000","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"import se.kth.edx.id2203.core.ExercisePrimitives.AddressUtils._<br />import se.kth.edx.id2203.core.Ports._<br />import se.kth.edx.id2203.validation._<br />import se.sics.kompics.network._<br />import se.sics.kompics.sl.{Init, _}<br />import se.sics.kompics.{KompicsEvent, ComponentDefinition=>_, Port=>_}<br />import scala.language.implicitConversions<br />import scala.collection.mutable.ListBuffer<br />import se.sics.kompics.timer.{ScheduleTimeout, Timeout, Timer}<br />"}]}},{"text":"%md\n\n## Leader-less Obstraction-Free Paxos for Single Value Consensus ##\n\nA (single value) Consensus Abstraction, in Kompics terms, is a component that **provides** the following port *(already imported in the notebook)*.\n\n     class Consensus extends Port{\n       request[C_Propose];\n       indication[C_Decide];\n     }\n\nAn **Consensus** component should request value proposals (`C_Propose`) and respond with decided value events (`C_Decide`) respectively as defined below:\n\n     case class C_Decide(value: Any) extends KompicsEvent;\n     case class C_Propose(value: Any) extends KompicsEvent;\n\nThe following properties define the expected behavior of a consensus abstraction more specifically:\n\n1. **Validity**: *Only proposed values may be decided.*\n2. **Uniform Agreement**: *No two nodes decide different values.*\n3. **Integrity**: *Each node can decide a value at most once.*\n4. **Termination**: *Every node eventually decides a value.*\n    \nThe recommended algorithm to use is the the one we call \"Leaderless Repeatable Paxos\" which initiates new proposal rounds until a decision has been made.\nYou can find the algorithm in the following  [document](https://courses.edx.org/asset-v1:KTHx+ID2203.1x+2016T3+type@asset+block@paxos-consensus.pdf) (pages 2-3).\n","dateUpdated":"2018-01-09T16:35:31+0000","config":{"editorMode":"ace/mode/markdown","colWidth":12,"editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true,"fontSize":9,"editorSetting":{"language":"markdown","editOnDblClick":true},"tableHide":false},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<div class=\"markdown-body\">\n<h2>Leader-less Obstraction-Free Paxos for Single Value Consensus</h2>\n<p>A (single value) Consensus Abstraction, in Kompics terms, is a component that <strong>provides</strong> the following port <em>(already imported in the notebook)</em>.</p>\n<pre><code> class Consensus extends Port{\n   request[C_Propose];\n   indication[C_Decide];\n }\n</code></pre>\n<p>An <strong>Consensus</strong> component should request value proposals (<code>C_Propose</code>) and respond with decided value events (<code>C_Decide</code>) respectively as defined below:</p>\n<pre><code> case class C_Decide(value: Any) extends KompicsEvent;\n case class C_Propose(value: Any) extends KompicsEvent;\n</code></pre>\n<p>The following properties define the expected behavior of a consensus abstraction more specifically:</p>\n<ol>\n  <li><strong>Validity</strong>: <em>Only proposed values may be decided.</em></li>\n  <li><strong>Uniform Agreement</strong>: <em>No two nodes decide different values.</em></li>\n  <li><strong>Integrity</strong>: <em>Each node can decide a value at most once.</em></li>\n  <li><strong>Termination</strong>: <em>Every node eventually decides a value.</em></li>\n</ol>\n<p>The recommended algorithm to use is the the one we call &ldquo;Leaderless Repeatable Paxos&rdquo; which initiates new proposal rounds until a decision has been made.<br/>You can find the algorithm in the following <a href=\"https://courses.edx.org/asset-v1:KTHx+ID2203.1x+2016T3+type@asset+block@paxos-consensus.pdf\">document</a> (pages 2-3).</p>\n</div>"}]},"apps":[],"jobName":"paragraph_1515514951752_-1961917220","id":"20160930-115754_781424547","dateCreated":"2018-01-09T16:22:31+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:342","user":"anonymous","dateFinished":"2018-01-09T16:35:31+0000","dateStarted":"2018-01-09T16:35:31+0000"},{"text":"  case class Prepare(proposalBallot: (Int, Int)) extends KompicsEvent;\n  case class Promise(promiseBallot: (Int, Int), acceptedBallot: (Int, Int), acceptedValue: Option[Any]) extends KompicsEvent;\n  case class Accept(acceptBallot: (Int, Int), proposedValue: Any) extends KompicsEvent;\n  case class Accepted(acceptedBallot: (Int, Int)) extends KompicsEvent;\n  case class Nack(ballot: (Int, Int)) extends KompicsEvent;\n  case class Decided(decidedValue: Any) extends KompicsEvent;\n\n  /**\n    * This augments tuples with comparison operators implicitly, which you can use in your code, for convenience. \n    * examples: (1,2) > (1,4) yields 'false' and  (5,4) <= (7,4) yields 'true' \n    */\n  implicit def addComparators[A](x: A)(implicit o: math.Ordering[A]): o.Ops = o.mkOrderingOps(x);\n  \n  //HINT: After you execute the latter implicit ordering you can compare tuples as such within your component implementation:\n  (1,2) <= (1,4);","dateUpdated":"2018-01-09T17:33:43+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"tableHide":false,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"fontSize":9,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1515514951752_-1961917220","id":"20160830-154940_1300846994","dateCreated":"2018-01-09T16:22:31+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:343","user":"anonymous","dateFinished":"2018-01-09T17:33:44+0000","dateStarted":"2018-01-09T17:33:43+0000","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"defined class Prepare<br />defined class Promise<br />defined class Accept<br />defined class Accepted<br />defined class Nack<br />defined class Decided<br />addComparators: [A](x: A)(implicit o: scala.math.Ordering[A])o.Ops<br />res8: Boolean = true<br />"}]}},{"text":"\nclass Paxos(paxosInit: Init[Paxos]) extends ComponentDefinition {\n\n  //Port Subscriptions for Paxos\n\n  val consensus = provides[Consensus];\n  val beb = requires[BestEffortBroadcast];\n  val plink = requires[PerfectLink];\n \n  //Internal State of Paxos\n  val (rank, numProcesses) = paxosInit match {\n    case Init(s: Address, qSize: Int) => (toRank(s), qSize)\n  }\n\n  //Proposer State\n  var round = 0;\n  var proposedValue: Option[Any] = None;\n  var promises: ListBuffer[((Int, Int), Option[Any])] = ListBuffer.empty;\n  var numOfAccepts = 0;\n  var decided = false;\n\n  //Acceptor State\n  var promisedBallot = (0, 0);\n  var acceptedBallot = (0, 0);\n  var acceptedValue: Option[Any] = None;\n\n  def propose() = {\n    if(!decided){\n      round = round + 1;\n      numOfAccepts = 0;\n      promises = ListBuffer.empty;\n      trigger(BEB_Broadcast(Prepare(round,rank)) -> beb);\n    }\n  }\n\n  consensus uponEvent {\n    case C_Propose(value) => handle {\n      proposedValue = Some(value);\n      propose();\n    }\n  }\n\n\n  beb uponEvent {\n\n    case BEB_Deliver(src, prep: Prepare) => handle {\n   /* \n   INSERT YOUR CODE HERE \n   */\n    };\n\n    case BEB_Deliver(src, acc: Accept) => handle {\n   /* \n   INSERT YOUR CODE HERE \n   */\n    };\n\n    case BEB_Deliver(src, dec : Decided) => handle {\n   /* \n   INSERT YOUR CODE HERE \n   */\n    }\n  }\n\n  plink uponEvent {\n\n    case PL_Deliver(src, prepAck: Promise) => handle {\n      if ((round, rank) == prepAck.promiseBallot) {\n        promises += ((prepAck.acceptedBallot, prepAck.acceptedValue));\n        if(promises.count == (numProcesses + 1) / 2){\n          /*todo: here*/\n        }\n      }\n    };\n\n    case PL_Deliver(src, accAck: Accepted) => handle {\n      if ((round, rank) == accAck.acceptedBallot) {\n        /* \n           INSERT YOUR CODE HERE \n        */\n      }\n    };\n\n    case PL_Deliver(src, nack: Nack) => handle {\n      if ((round, rank) == nack.ballot) {\n        /* \n           INSERT YOUR CODE HERE \n        */\n      }\n    }\n  }\n  \n \n};","dateUpdated":"2018-01-09T17:50:57+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"tableHide":false,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"fontSize":9,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1515514951752_-1961917220","id":"20160830-154952_592749615","dateCreated":"2018-01-09T16:22:31+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:344","user":"anonymous","dateFinished":"2018-01-09T17:34:51+0000","dateStarted":"2018-01-09T17:34:51+0000","results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"defined class Paxos<br />"}]}},{"text":"checkSingleValueConsensus[Paxos]();","dateUpdated":"2018-01-09T16:22:31+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"tableHide":false,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"fontSize":9,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1515514951752_-1961917220","id":"20160830-155009_392534435","dateCreated":"2018-01-09T16:22:31+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:345"},{"dateUpdated":"2018-01-09T16:22:31+0000","config":{"editorMode":"ace/mode/scala","colWidth":12,"tableHide":false,"enabled":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"fontSize":9,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false}},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1515514951752_-1961917220","id":"20160830-155043_337959288","dateCreated":"2018-01-09T16:22:31+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:346"}],"name":"Exercise-Consensus","id":"2D4MCXHAJ","angularObjects":{"2BKQCVH92:shared_process":[],"2CVXXPNWV:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}